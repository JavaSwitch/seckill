## 分布式商品秒杀系统

本商品秒杀系统是主要依赖于Redis实现的，在高并发场景下，传统的DB层会出现瓶颈，因此，考虑到更是秒杀场景，直接上Redis替代DB，等秒杀结束后，数据最终会落地到DB。Redis在高并发下，10万+的QPS，轻松缓解秒杀业务带来了流量压力。

## 开发环境

JDK8 + Maven + Spring + SpringMVC + MyBatis Plus + Redis + RocketMQ + MySQL 

## 实现技术点

1. 解决超卖问题

   在商品秒杀开始前对商品进行预热操作，把商品秒杀的信息和库存数量存储在redis上。在秒杀开始前，后端去Redis查询商品秒杀信息，把信息和库存返回给前端。当秒杀开始后，后端利用Redis+Lua脚本的原子性，去操作预减库存，保证了库存不出现超卖的情况。

2. 动态秒杀接口

   在秒杀开始前，是不允许暴露秒杀接口的，目的是为了防止用户用恶意程序或软件去刷后端的接口，因此秒杀接口需要在秒杀开启后动态生成。

   秒杀接口Url是”商品ID+用户ID“通过MD5+salt的进行动态生成一个接口。

   在秒杀开始前，不暴露秒杀接口，也就是下单接口。当秒杀开始后，下单操作先获取查看秒杀是否开始，如果开始了，那么就返回一个动态生成的接口，然后前端根据秒杀接口进行发起秒杀，后端接收到秒杀后，再通过动态的接口进行校验，最后进行下单操作。

3. RocketMQ异步下单

   下单执行异步操作，请求直接返回。秒杀成功后的订单投递到RocketMQ中，由消费者去消费生成订单，避免流量太大，请求堆积在后端。

4. 限流

    实现一个AOP注解@Accesslimit，对每个用户访问秒杀接口的频率限制在一定速率上，利用Redis记录每个用户访问秒杀接口的频率，并且可以设定过期时间，也就是在多少时间内可以访问多少次秒杀接口，同时也达到防刷的目的，避免个别用户恶意刷动态暴露的接口。



## 待更新

+ 用户登录接口

+ 前端页面静态化

+ 完善业务属性

+ 服务降级

+ ......

  

## 总结

本项目由作者学习了分布式架构后，结合常见的秒杀场景去学习和总结，并想通过实际的操作来模拟一个真实的业务场景，后续的功能作者会加快进度，日益完善，谢谢大家。